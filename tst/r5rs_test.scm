#!/home/per/git/scm/scheme

(define (expect x)
  (if (not (eval x environment))
      (error "Unit test failure" x)))

(define (test-quote)
  (expect '(symbol? (quote a)))
  (expect '(equal? (quote #(a b c)) '#(a b c)))
  (expect '(equal? (quote (+ 1 2)) '(+ 1 2)))
  (expect '(equal? '#(a b c) #(a b c)))
  (expect '(equal? ''a '(quote a)))
  (expect '(not (symbol? '())))
  (expect '(null? '()))
  )

(define (test-quasiquote)
  (expect '(equal? `(list ,(+ 1 2) 4) '(list 3 4)))
  (expect '(equal? (let ((name 'a)) `(list ,name ',name)) 
		   '(list a (quote a))))
  )

(define (test-eq?)
  (expect '(eq? 'a 'a))
  (expect '(not (eq? (list 'a) (list 'a))))
  (expect '(eq? '() '()))
  (expect '(eq? car car))
  (expect '(let ((x '(a))) (eq? x x)))
  ;;(let (( x '#()))
  ;;  (expect (eq? x x)))
  (expect '(let ((p (lambda (x) x))) (eq? p p)))
  )

(define (test-eqv?)
  (expect '(not (eqv? 1 "")))
  ;; tests from list
  (expect '(eqv? 'a 'a))
  (expect '(not (eqv? 'a 'b)))
  (expect '(eqv? 2 2))
  (expect '(eqv? '() '()))
  (expect '(not (eqv? (cons 1 2) (cons 1 2))))
  (expect '(not (eqv? (lambda () 1) (lambda () 2))))
  (expect '(not (eqv? #f '())))
  (expect '(let ((p (lambda (x) x))) (eqv? p p)))
  )

(define (test-equal?)
  (expect '(equal? 'a 'a))
  (expect '(equal? '(a) '(a)))
  (expect '(equal? '(a (b) c) '(a (b) c)))
  (expect '(equal? "abc" "abc"))
  )

(define (test-memq?)
  (expect '(equal? (memq 'a '(a b c)) '(a b c)))
  (expect '(equal? (memq 'b '(a b c)) '(b c)))
  (expect '(equal? (memq 'a '(b c d)) #f))
  (expect '(equal? (memq (list 'a) '(b (a) c)) #f))
  (expect '(equal? (member (list 'a) '(b (a) c)) '((a) c)))
					; (expect (equal? (memq 101 â€™(100 101 102)) unspecified
  (expect '(equal? (memv 101 '(100 101 102)) '(101 102)))
  )

(define (test-assq)
  (expect '(let ((e '((a 1) (b 2) (c 3)))) (eq? (assq 'a e) (car e))))
  (expect '(let ((e '((a 1) (b 2) (c 3)))) (eq? (assq 'b e) (cadr e))))
  (expect '(let ((e '((a 1) (b 2) (c 3)))) (eq? (assq 'd e) #f)))
  (expect '(let ((e '((a 1) (b 2) (c 3)))) (eq? (assq (list 'a) '(((a)) ((b)) ((c)))) #f)))
  )

(define (test-or)
  (expect '(or (= 2 2) (> 2 1)))
  (expect '(or (= 2 2) (< 2 1)))
  (expect '(not (or #f #f #f)))
  (expect '(equal? (or (memq 'b '(a b c))
		       (/ 3 0)) 
		   '(b c)))
  (expect '(or #f (or #f #t)))
  )

(define (test-and)
  (expect '(and (= 2 2) (> 2 1)))
  (expect '(not (and (= 2 2) (< 2 1))))
  (expect '(equal? (and 1 2 'c '(f g)) '(f g)))
  (expect '(and))
  (expect '(and #t (and #t)))
  )

(define (test-let)
  (expect '(= (let ((x 2) (y 3))
		(* x y))
	      6))
  (expect '(= (let ((x 2) (y 3))
		(let ((x 7)
		      (z (+ x y)))
		  (* z x)))
	      35))
  (expect '(= (let ((x 2) (y 3))
		(let* ((x 7)
		       (z (+ x y)))
		  (* z x)))
	      70))
  (expect '(letrec ((even?
		     (lambda (n)
		       (if (zero? n)
			   #t
			   (odd? (- n 1)))))
		    (odd?
		     (lambda (n)
		       (if (zero? n)
			   #f
			   (even? (- n 1))))))
	     (even? 88)))
  (expect '(equal? (let loop ((numbers '(3 -2 1 6 -5))
			      (nonneg '())
			      (neg '()))
		     (cond ((null? numbers) (list nonneg neg))
			   ((>= (car numbers) 0)
			    (loop (cdr numbers)
				  (cons (car numbers) nonneg)
				  neg))
			   ((< (car numbers) 0)
			    (loop (cdr numbers)
				  nonneg
				  (cons (car numbers) neg)))))
		   '((6 1 3) (-5 -2))))
  (expect '(let ((a (or #f (or #t)))) a))
  (expect '(let () #t))
  )

(define (test-let-extra)
  (expect '(= (let () 1 2) 2))
  )

(define (test-cond)
  (expect '(equal? (cond ((> 3 2) 'greater)
			 ((< 3 2) 'less))
		   'greater))
  (expect '(equal? (cond ((> 3 3) 'greater)
			 ((< 3 3) 'less)
			 (else 'equal))
		   'equal))
  ;; (expect (equal? (cond ((assv 'b '((a 1) (b 2))) => cadr)
  ;; 			(else #f))
  ;; 		  2))
  )

(define (test-case)
  (expect '(equal? (case (* 2 3)
					 ((2 3 5 7) 'prime)
					 ((1 4 6 8 9) 'composite))
				   'composite))
  ;; (expect (case (car '(c d)) how to test unspecified
  ;; 	   ((a) 'a)
  ;; 	   ((b) 'b)) unspecifed)
  (expect '(case (car '(c d))
			 ((a e i o u) 'vowel)
			 ((w y) 'semivowel)
			 (else 'consonant))
		  'consonant)
  )

(define (test-control)
  (expect '(procedure? car))
  (expect '(not (procedure? 'car)))
  (expect '(procedure? (lambda (x) (* x x))))
  (expect '(not (procedure? '(lambda (x) (* x x)))))
  )

(define list-length
  (lambda (obj)
	(call-with-current-continuation
	 (lambda (return)
	   (letrec ((r (lambda (obj)
					 (cond ((null? obj) 0)
						   ((pair? obj)
							(+ (r (cdr obj)) 1))
						   (else (return #f))))))
		 (r obj))))))

(define (test-call/cc)
  (expect '(call-with-current-continuation
			(lambda (exit)
			  (for-each (lambda (x)
						  (if (negative? x)
							  (exit x)))
						'(54 0 37 -3 245 19))))
		  -3)
  (expect '(equal? (list-length '(1 2 3 4))
				   4))
  (expect '(equal? (list-length '(a b . c))
				   #f))
  )

(define (test)
  (test-quote)
  (test-quasiquote)
  (test-or)
  (test-and)
  (test-eq?)
  (test-eqv?)
  (test-equal?)
  (test-memq?)
  (test-assq)
  (test-let)
  (test-let-extra)
  (test-cond)
  (test-case)
  (test-control)
  (test-call/cc)
  (display "tests ok")
  (newline)
  )

(test)

;; (load "r5rs_test.scm")
