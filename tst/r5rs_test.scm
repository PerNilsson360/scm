#!/home/per/prg/git/scm/scheme

(define (expect x) 
  (if (not x)
      (error "Unit test failure")))

(define (test-quote)
  (begin (expect (symbol? (quote a)))
	 ;(expect (equal? (quote #(a b c)) '#(a b c))) fix equal for arrays
	 (expect (equal? (quote (+ 1 2)) '(+ 1 2)))
	 ;(expect (equal? '#(a b c) #(a b c)))
	 (expect (equal? ''a '(quote a)))
	 ))

(define (test-quasiquote)
  (begin (expect (equal? `(list ,(+ 1 2) 4) '(list 3 4)))
	 (expect (equal? (let ((name 'a)) `(list ,name ',name)) 
			 '(list a (quote a))))
	 ))

(define (test-eq?)
  (begin (expect (eq? 'a 'a))
	 (expect (not (eq? (list 'a) (list 'a))))
	 (expect (eq? '() '()))
	 (expect (eq? car car))
	 (let ((x '(a)))
	   (expect (eq? x x)))
	 ;;(let (( x '#()))
	 ;;  (expect (eq? x x)))
	 (let ((p (lambda (x) x)))
	   (expect (eq? p p)))
	 ))

(define (test-eqv?)
  (begin (expect (not (eqv? 1 "")))
	 ;; tests from list
	 (expect (eqv? 'a 'a))
	 (expect (not (eqv? 'a 'b)))
	 (expect (eqv? 2 2))
	 (expect (eqv? '() '()))
	 (expect (not (eqv? (cons 1 2) (cons 1 2))))
	 (expect (not (eqv? (lambda () 1) (lambda () 2))))
	 (expect (not (eqv? #f '())))
	 (let ((p (lambda (x) x)))
	   (expect (eqv? p p)))
	 ))

(define (test-equal?)
  (begin (expect (equal? 'a 'a))
	 (expect (equal? '(a) '(a)))
	 (expect (equal? '(a (b) c) '(a (b) c)))
	 (expect (equal? "abc" "abc"))
	 ))

(define (test-memq?)
  (begin (expect (equal? (memq 'a '(a b c)) '(a b c)))
	 (expect (equal? (memq 'b '(a b c)) '(b c)))
	 (expect (equal? (memq 'a '(b c d)) #f))
	 (expect (equal? (memq (list 'a) '(b (a) c)) #f))
	 (expect (equal? (member (list 'a) '(b (a) c)) '((a) c)))
	 ; (expect (equal? (memq 101 â€™(100 101 102)) unspecified
	 (expect (equal? (memv 101 '(100 101 102)) '(101 102)))
	 ))

(define (test-assq)
  (let ((e '((a 1) (b 2) (c 3))))
    (begin (expect (eq? (assq 'a e) (car e)))
	   (expect (eq? (assq 'b e) (cadr e)))
	   (expect (eq? (assq 'd e) #f))
	   (expect (eq? (assq (list 'a) '(((a)) ((b)) ((c)))) #f))
	   )))

(define (test-or)
  (begin (expect (or (= 2 2) (> 2 1)))
	 (expect (or (= 2 2) (< 2 1)))
	 (expect (not (or #f #f #f)))
	 (expect (equal? (or (memq 'b '(a b c))
			     (/ 3 0)) 
			 '(b c)))))

(define (test-and)
  (begin (expect (and (= 2 2) (> 2 1)))
	 (expect (not (and (= 2 2) (< 2 1))))
	 (expect (equal? (and 1 2 'c '(f g)) '(f g)))
	 (expect (and))))

(define (test-let)
  (begin (expect (= (let ((x 2) (y 3))
		      (* x y))
		    6))
	 (expect (= (let ((x 2) (y 3))
		      (let ((x 7)
			    (z (+ x y)))
			(* z x)))
		    35))
	 (expect (= (let ((x 2) (y 3))
		      (let* ((x 7)
			     (z (+ x y)))
			(* z x)))
		    70))
	 (expect (letrec ((even?
			   (lambda (n)
			     (if (zero? n)
				 #t
				 (odd? (- n 1)))))
			  (odd?
			   (lambda (n)
			     (if (zero? n)
				 #f
				 (even? (- n 1))))))
		   (even? 88)))
	 (expect (equal? (let loop ((numbers '(3 -2 1 6 -5))
				    (nonneg '())
				    (neg '()))
			   (cond ((null? numbers) (list nonneg neg))
				 ((>= (car numbers) 0)
				  (loop (cdr numbers)
					(cons (car numbers) nonneg)
					neg))
				 ((< (car numbers) 0)
				  (loop (cdr numbers)
					nonneg
					(cons (car numbers) neg)))))
			 '((6 1 3) (-5 -2))))))

(define (test-cond)
  (expect (equal? (cond ((> 3 2) 'greater)
			((< 3 2) 'less))
		  'greater))
  (expect (equal? (cond ((> 3 3) 'greater)
			((< 3 3) 'less)
			(else 'equal))
		  'equal))
  ;; (expect (equal? (cond ((assv 'b '((a 1) (b 2))) => cadr)
  ;; 			(else #f))
  ;; 		  2))
  )

(define (test-case)
  (begin (expect (equal? (case (* 2 3)
			   ((2 3 5 7) 'prime)
			   ((1 4 6 8 9) 'composite)) 'composite))
	 ;; (expect (case (car '(c d)) how to test unspecified
	 ;; 	   ((a) 'a)
	 ;; 	   ((b) 'b)) unspecifed)
	 (expect (case (car '(c d))
		   ((a e i o u) 'vowel)
		   ((w y) 'semivowel)
		   (else 'consonant)) 'consonant)))  
(define (test)
  (test-quote)
  (test-quasiquote)
  (test-or)
  (test-and)
  (test-eq?)
  (test-eqv?)
  (test-equal?)
  (test-memq?)
  (test-assq)
  (test-let)
  ;;(test-cond)
  ;;(test-case)
  (display "tests ok")
  )

(test)

;; (load "r5rs_test.scm")
