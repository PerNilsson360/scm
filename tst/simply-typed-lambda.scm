; (load "/home/per/prg/git/scm/tst/simply-typed-lambda.scm")
(define (assert condition . args)
  (if (not condition) (error "ASSERT:" args)))

(define (println . args) (display args) (newline))

(define (eval-scm exp env)
  (println "eval-scm" exp)
  (cond ((self-evaluating? exp) exp)
	((variable? exp) (lookup-variable-value exp env))
	((definition? exp) exp)		; handled by type-check
	((lambda? exp) exp)		; evaluates to itself
	((application? exp)
	 (apply-scm
	  (actual-value (operator exp) env) (operands exp) env))
	(else (error "Unknown expression type -- EVAL-SCM" exp))))

(define (apply-scm val args env)
  (println "apply-scm" val args)
  (cond ((primitive-procedure? val)
	 (apply-primitive-procedure val (list-of-arg-vals args)))
	((constant? val) (cons val args))
	((lambda? val) 
	 (eval-sequence
	  (lambda-body val)
	  (extend-val-env (lambda-parameters val)
			  (list-of-delayed-args args env)
			  env)))
	(else (error "Unknown procedure type -- APPLY-SCM"))))

(define (type-check-scm exp env)
  (cond ((self-evaluating? exp) (self-eval-type exp))
	((variable? exp) (lookup-variable-type exp env))
	((definition? exp) (eval-definition exp env))
	((lambda? exp) (display "lambda typing needs impl"))
	((application? exp) (type-check-application exp env))
	(else (error "TYPE-CHECK_SCM: unkown expression" exp))))

(define (list-of-arg-vals exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps) env)
	    (list-of-arg-vals (rest-operands exps) env))))

(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps) env)
	    (list-of-delayed-args (rest-operands exps) env))))

(define (eval-sequence exps env)
  (if (last-exp? exps) 
      (eval-scm (first-exp exps) env)
      (begin (eval-scm (first-exp exps) env)
	     (eval-sequence (rest-exps exps) env))))

(define (eval-definition exp env)
  (let ((var (definition-variable exp))
	(def-type (definition-type exp)))
    (if (definition-of-constant? exp)
	(define-variable! var (make-constant var) def-type env)
	(let* ((val (definition-value exp))
	       (check-type (eval-type var val def-type env)))
	  (if (not (eq? check-type 'bottom))
	      (define-variable! var val def-type env)
	      'bottom)))))

(define (self-eval-type val)
  (cond ((integer? val) 'int)
	((string? val) 'string)
	(else 'bottom)))

(define (return-fail-type id) 'bottom)

(define (list-of-types rands env)
  (if (null? rands)
      '()
      (cons (infer-type (car rands) env)
	    (list-of-types (cdr rands) env))))

(define (type-check-application exp env)
  (println "type-check-application" exp)
  (let* ((rator (operator exp))
	 (operator-type (infer-type rator env))
	 (rands (operands exp))
	 (operand-types (list-of-types rands env)))
    (if (match-types (parameter-types operator-type) operand-types)
	(return-type operator-type)
	(return-fail-type rator))))

(define (infer-type exp env)
  (cond ((self-evaluating? exp) (self-eval-type exp))
	((variable? exp) (lookup-variable-type exp env))
	((application? exp) (type-check-application exp env))
	(else (return-fail-type exp))))

(define (type-check-lambda proc type env)
  (let ((infered-type (infer-type
		       (lambda-body proc)
		       (extend-type-env
			(lambda-parameters proc)
			(parameter-types type)
			env)))
	(specified-type (return-type type)))
    (if (not (eq? infered-type specified-type))
	(begin (display "Typechecking failed infered type:")
	       (user-print infered-type)
	       (display " specified type: ")
	       (user-print specified-type)
	       (newline)
	       'bottom)
	infered-type)))
	
(define (type-check-val val type)
  (display (list "type-check-val" val)) (newline)
  (cond ((and (integer? val) (eq? type 'int)) 'int)
	((and (string? val) (eq? type 'string)) 'string)
	(else 'bottom)))

(define (type-decl? type) (eq? type 'type))
(define (check-type-decl var val env)
  (assert (null? val) "CHECK-TYPE-DECL: val must be nil")
  (if (is-var-defined? var env)
      (begin (println "Type is allready defined" var)
	     'bottom)
      'type))
       
;; Type checks a value which has been evalated.
(define (eval-type var val type env)
  (cond ((lambda? val) (type-check-lambda val type env))
	((type-decl? type) (check-type-decl var val env))
	((null? val) type)		   ; algebraic data type
	(else (type-check-val val type)))) ; @todo remove this

(define (self-evaluating? exp)
  (or (number? exp) (string? exp) (constant? exp)))
(define (variable? exp) (symbol? exp))
(define (tagged-list? exp tag) (and (pair? exp) (eq? (car exp) tag)))

(define (match-fun-arg-types fun-type arg-types)
  (cond ((not (fun-type? fun-type?))
	 (begin (display"argument is not a function") #f))
	((not (equal? (parameter-types fun-type) arg-types))
	 (begin (display"specified argument type does not match") #f))
	(else #t)))
	      
(define (match-types a b) (equal? a b))
(define (valid-type? t) (not (eq? t 'bottom)))

(define (parameter-types type)
  (if (not (tagged-list? type 'lambda))
      (error "PARAMETER-TYPES: must be a function type" type))
      (cadr type))

(define (return-type type)
  (if (not (tagged-list? type 'lambda))
      (error "return-type: must be a function type" type)
      (caddr type)))

(define (fun-def? exp) (pair? (cadr exp)))
(define (fun-vars sexp)
  (define (inner res vars)
    (if (null? vars)
	res
	(let ((var (car vars)))
	  (if (lambda? var)
	      (inner res (cdr vars))
	      (inner (cons var res) (cdr vars))))))
  (reverse (inner '() (cdadr sexp))))

(define (fun-type exp)
  (define (inner exps)
    (if (null? exps)
	'()
	(let ((exp (car exps)))
	  (if (lambda? exp)
	      exp
	      (inner (cdr exps))))))
  (inner (cdadr exp)))

(define (definition? exp)
  (and (tagged-list? exp 'define)
       (assert (> (length exp) 2)
	       "need at least 2 args in define"
	       exp)))

(define (definition-variable exp)
  (let ((var (cadr exp)))
    (assert (symbol? var) "definition variable must be a symbol")
    var))
  
(define (definition-type exp) (caddr exp))
(define (definition-of-constant? exp) (= (length exp) 3))
(define (definition-value exp) (cadddr exp))

(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp)
  (let ((body (cddr exp)))
    (if (null? body)
	'()
	(and (assert (<= (length body) 1)
		     "can not have more than one exp in a lambda")
	     (car body)))))
	
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))

(define (constant? exp) (tagged-list? exp 'constant))
(define (make-constant name) (list 'constant name))
(define (constant-name constant) (cadr constant))
(define (constant-args constant) (caddr constant))

(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq)) 
(define (rest-exps seq) (cdr seq))

(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))

(define (actual-value exp env) (force-it (eval-scm exp env)))

;; thunks
(define (delay-it exp env) (list exp env))
(define (thunk? obj) (tagged-list? obj 'thunk))
(define (thunk-exp thunk) (cadr thunk))
(define (thunk-env thunk) (cadr thunk))
(define (evaluated-thunk? obj) (tagged-list? obj 'evaluated-thunk))
(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))
(define (force-it obj)
  (cond ((thunk? obj)
	 (let ((result (actual-value (thunk-exp obj) (thunk-env obj))))
	   (set-car! obj 'evaluated-thunk)
	   (set-car! (cdr obj) result)
	   (set-cdr! (cdr obj) '())
	   result))
	((evaluated-thunk? obj) (thunk-value obj))
	(else obj)))


;; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

(define (make-frame-entry var val type) (list var val type))
(define (frame-entry-var entry) (car entry))
(define (frame-entry-val entry) (cadr entry))
(define (frame-entry-type entry) (caddr entry))

(define (make-type-frame vars types)
  (define (inner vars types result)
    (if (null? vars)
	(reverse result)
	(inner (cdr vars)
	       (cdr types)
	       (cons (make-frame-entry (car vars) '() (car types))
		     result))))
  (cons 'frame (inner vars types '())))

(define (make-val-frame vars vals)
  (define (inner vars vals result)
    (if (null? vars)
	(reverse result)
	(inner (cdr vars)
	       (cdr vals)
	       (cons (make-frame-entry (car vars) (car vals) '())
		     result))))
  (cons 'frame (inner vars vals '())))


(define (make-frame vars vals types)
  (define (inner vars vals types result)
    (if (null? vars)
	(reverse result)
	(inner (cdr vars)
	       (cdr vals)
	       (cdr types)
	       (cons (make-frame-entry (car vars)
				       (car vals)
				       (car types))
		     result))))
  (cons 'frame (inner vars vals types '())))
  
(define (frame-entries frame) (cdr frame))
(define (add-binding-to-frame! binding frame)
  (set-cdr! frame (cons binding (cdr frame))))

(define (extend-type-env vars types base-env)
  (if (or (= (length vars) (length types)))
      (let* ((frame (make-type-frame vars types))
	     (env (cons frame base-env)))
	env)
      (error "EXTEND-TYPE-ENV: wrong number of values"
	     vars types)))

(define (extend-val-env vars vals base-env)
  (if (or (= (length vars) (length vals)))
      (let* ((frame (make-val-frame vars vals))
	     (env (cons frame base-env)))
	env)
      (error "EXTEND-VAL-ENV: wrong number of values"
	     vars vals)))

(define (extend-environment vars vals types base-env)
  (if (or (= (length vars) (length vals) (length types)))
      (let* ((frame (make-frame vars vals types))
	     (env (cons frame base-env)))
	env)
      (error "EXTEND-ENVIRONMENT: wrong number of values"
	     vars vals types)))

(define (is-var-defined? var env)
  (define (env-loop env)
    (define (inner entries)
      (cond ((null? entries) (env-loop (enclosing-environment env)))
            ((eq? var (frame-entry-var (car entries))) #t)
	    (else (inner (cdr entries)))))
    (if (eq? env the-empty-environment)
	#f
	(inner (frame-entries (first-frame env)))))
  (env-loop env))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (inner entries)
      (cond ((null? entries)
             (env-loop (enclosing-environment env)))
            ((eq? var (frame-entry-var (car entries)))
             (frame-entry-val (car entries)))
	    (else (inner (cdr entries)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
	(inner (frame-entries (first-frame env)))))
  (env-loop env))

(define (lookup-variable-type var env)
  (define (env-loop env)
    (define (inner entries)
      (display var) (newline)
      (cond ((null? entries)
             (env-loop (enclosing-environment env)))
            ((eq? var (frame-entry-var (car entries)))
             (frame-entry-type (car entries)))
	    (else (inner (cdr entries)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
	(inner (frame-entries (first-frame env)))))
  (env-loop env))

(define (define-variable! var val type env)
  (let ((frame (first-frame env)))
    (define (inner entries)
      (cond ((null? entries)
	     (add-binding-to-frame!
	      (make-frame-entry var val type)
	      frame))
	    ((eq? var (frame-entry-var (car entries)))
	     (set-cdr! (car entries) (list val type)))
	    (else (inner (cdr entries)))))
    (begin (inner (frame-entries frame)) type)))
  
(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
			     (primitive-procedure-types)
                             the-empty-environment)))
    (define-variable! 'true #t 'bool initial-env)
    (define-variable! 'false #f 'bool initial-env)
    initial-env))

(define (primitive-procedure? proc) (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures 
  (list (list '+ + '(lambda (int int) int))
	(list '- - '(lambda (int int) int))
	(list '* * '(lambda (int int) int))
	(list '= = '(lambda (int int) int))
        ))

(define (primitive-procedure-names) (map car primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (primitive-procedure-types) (map caddr primitive-procedures))

(define (apply-primitive-procedure proc args)
  (apply (primitive-implementation proc) args))

(define input-prompt "input:")
(define output-prompt "val:")

(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (display input)
    (if (not (equal? input '(quit)))
	(let ((type (type-check-scm input the-global-environment)))
	  (if (eq? type 'bottom)
	      (begin (display (list "Typechecking failed on" input))
		     (newline)
		     (driver-loop))
	      (let ((output (actual-value input the-global-environment)))
		(announce-output output-prompt)
		(user-print output)
		(user-print "type")
		(user-print type)
		(driver-loop)))))))
    
(define (prompt-for-input string) (newline) (display string))

(define (announce-output string) (newline) (display string))

(define (user-print object)
  (cond ((constant? object) (constant-name object))
	((pair? object)
	 (let ((c (car object)))
	   (if (constant? c)
	       (display (cons (constant-name c) (cdr object)))
	       (display object))))
	(else (display object))))

(define the-global-environment (setup-environment))

;(driver-loop)
